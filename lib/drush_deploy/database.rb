require 'capistrano'
require 'drush_deploy/error'
require 'drush_deploy/configuration'
require 'yaml'

module DrushDeploy
  class Database
    class Error < DrushDeploy::Error; end
    class ConfigNotFound < Error
      def initialize(site_name,db_name)
        super "Couldn't locate database configuration #{site_name}/#{db_name}. Please check your database configuration."
      end
    end
    class FieldNotFound < Error
      def initialize(key,site_name = 'default',db_name = 'default')
        key = [key] unless key.is_a? Array
        key = key.map {|k| "'#{k}'"}.join(',')

        super "Couldn't find #{key} field#{key.size == 1 ? '' : 's'} in database configuration #{site_name}/#{db_name}."\
              " Please check your database configuration."
      end
    end


    STANDARD_KEYS = %w(driver database username password host port prefix collation).map &:to_sym
    MANAGE_KEYS   = %w(driver database username password host port prefix 
                       admin_username admin_password).map &:to_sym
  
    def initialize(config)
      @config = config
      @seen_paths = {}
      @db_status = {}
    end

    def method_missing(sym, *args, &block)
      if @config.respond_to?(sym)
        @config.send(sym, *args, &block)
      else
        super
      end
    end

    def configure
      databases_path.find do |val|
        set :databases, load_path( val, databases )
        MANAGE_KEYS.all? {|k| databases.key? k}
      end
    end

    def load_path(path,databases = {})
      unless @seen_paths[path]
        logger.info "Trying to load database setting from #{path.inspect}"
        if path !~ /^[\/~]/
          path = latest_release+"/"+path
        end
        if path =~ /.php$/
          @seen_paths[path] = load_php_path path
        elsif path =~ /.yml$/
          @seen_paths[path] = load_yml_path path
        else
          throw Error.new "Unknown file type: #{path}"
        end
      end
      DrushDeploy::Database.deep_merge(@seen_paths[path],databases)
    end

    def load_php_path(path)
      prefix = ''
      if path.sub!(/^~/,'')
        prefix = "getenv('HOME')." 
      end

      script = <<-END.gsub(/^ */,'')
        <?php
        $filename = #{prefix}'#{path}';
        if( file_exists($filename) ) {
          require_once($filename);
          if( isset($databases) ) {
            print json_encode($databases);
          }
        } 
      END

      tmp = capture('mktemp').strip
      put script, tmp, :once => true
      resp = capture "#{remote_drush} php-script '#{tmp}' && rm -f '#{tmp}'"
      
      settings = {}
      unless resp.empty?
        resp = JSON.parse(resp)
        if resp != []
          settings = resp
        end
      end
      settings
    end

    def load_yml_path(path)
      prefix = ''
      if path.sub!(/^~/,'')
        prefix = '"$HOME"'
      end

      yaml =  capture("[ ! -e #{prefix}'#{path}' ] || cat #{prefix}'#{path}'")
      if yaml.empty?
        {}
      else
        credentials = YAML.load yaml
        DrushDeploy::Configuration.normalize_value(credentials)
      end
    end

    def update_settings(settings,template = 'sites/default/default.settings.php')
      if template !~ /^[\/~]/
        template = latest_release+"/"+template
      end
      prefix = ''
      if template.sub!(/^~/,'')
        prefix = "getenv('HOME')." 
      end
      script = <<-END.gsub(/^ */,'')
        <?php
        define('DRUPAL_ROOT', '#{latest_release}');
        define('MAINTENANCE_MODE', 'install');

        $template = #{prefix}'#{template}';
        $default = DRUPAL_ROOT.'/sites/default/default.settings.php';
        $backup = '/tmp/default_settings_backup.php';

        $databases = json_decode('#{settings.to_json}');
        $comment = 'Generated by drush-deploy';
        $version = explode('.',drush_drupal_version());
        if($version[0] < 7) {
          $vals = $databases['default']['default'];
          $db_url = sprintf('%s://%s:%s@%s:%s/%s',
            $vals['driver'],$vals['username'],$vals['password'],
            $vals['host'], $vals['port'], $vals['database']);
          $settings["db_url"] = array( 'comment' => $comment,
                                          'value' =>  $db_url);
          $settings["db_prefix"] = array( 'comment' => $comment,
                                          'value' =>  $vals['prefix']);
        } else {
          $settings["databases"] = array( 'comment' => $comment,
                                          'value' => $databases );
        }

        require_once(DRUPAL_ROOT.'/includes/bootstrap.inc');
        require_once(DRUPAL_ROOT.'/includes/install.inc');

        $backed_up = false;
        if ($template != $default && file_exists($default)) {
          rename($default,$backup);
          $backed_up = true;
        }
        rename($template,$default);
        drupal_rewrite_settings($settings);
        if ($backed_up) {
          rename($backup,$default);
        }
        __END__
      END

      run %Q{TMP=`mktemp` && sed -n '/^__END__$/ q; p' > $TMP && cd '#{latest_release}' && #{remote_drush} php-script $TMP && rm -f "$TMP"},
          :data => script
    end

    def updatedb
      run "cd '#{latest_release}' && #{remote_drush} updatedb --yes", :once => true
    end

    def config(*args)
      options = (args.size>0 && args.last.is_a?(Hash)) ? args.pop : {}
      db_name = args[0] || :default
      instance_name = args[1] || :default
      if databases[db_name] && databases[db_name][instance_name]
        conf = databases[db_name][instance_name].dup
      else
        throw ConfigNotFound.new db_name,instance_name
      end
      if options[:admin] && conf[:admin_username]
        conf[:username] = conf[:admin_username]
        conf[:password] = conf[:admin_password]
      end
      conf.merge options
    end

    def remote_sql(sql,options={})
      url = options[:config] ? DrushDeploy::Database.url(options[:config]) : nil
      tmp = capture('mktemp').strip
      put(sql,tmp)
      cmd = %Q{cd '#{latest_release}' && #{remote_drush} sql-cli #{url ? "--db-url='#{url}'" : ''} < '#{tmp}' && rm -f '#{tmp}'}
      if options[:capture]
        capture(cmd)
      else
        run cmd, :once => true
      end
    end

    def db_empty?(db = nil, conf_name = nil)
      conf = config(conf_name)
      conf[:database] = db if db
      db = conf[:database]
      if @db_status[db].nil?
        throw FieldNotFound.new 'database' unless conf[:database]
        logger.info "Fetching status of db #{conf[:database]}"
        sql = %q{SELECT count(*) FROM information_schema.tables 
                 WHERE table_schema = '%{database}' LIMIT 1} % conf
        conf[:database] = 'information_schema'
        res = remote_sql(sql, :config => conf, :capture => true)
        @db_status[db] = res.split(/\n/)[1].to_i == 0
      end
      @db_status[db]
    end

    def db_versions(db = nil, conf_name = nil)
      conf = config(conf_name,:admin => true)
      conf[:database] = db if db
      throw FieldNotFound.new 'database' unless conf[:database]
      logger.info "Getting list of databases versions"
      sql = %q{SELECT SCHEMA_NAME FROM information_schema.SCHEMATA
               WHERE SCHEMA_NAME REGEXP '%{database}_[0-9]+';} % conf
      (remote_sql(sql, :config => conf, :capture => true).split(/\n/)[1..-1] || []).sort.reverse
    end

    def db_exists?(db = nil, conf_name = nil)
      conf = config(conf_name,:admin => true)
      conf[:database] = db if db
      throw FieldNotFound.new 'database' unless conf[:database]
      logger.info "Checking existence of #{conf[:database]}"
      sql = %q{SELECT COUNT(*) FROM information_schema.SCHEMATA WHERE SCHEMA_NAME = '%{database}';} % conf
      conf[:database] = 'information_schema'
      remote_sql(sql, :config => conf, :capture => true).split(/\n/)[1].to_i != 0
    end

    def db_tables(db = nil, conf_name = nil)
      conf = config(conf_name,:admin => true)
      conf[:database] = db if db
      db = conf[:database]
      throw FieldNotFound.new 'database' unless conf[:database]
      logger.info "Fetching table list of #{conf[:database]}"
      db_tables_query = %q{SELECT table_name FROM information_schema.tables
                           WHERE table_schema = '%{database}'
                             AND table_type = 'BASE TABLE'};
      sql = db_tables_query % conf
      conf[:database] = 'information_schema'
      tables = remote_sql(sql, :config => conf, :capture => true).split(/\n/)[1..-1] || []
      @db_status[db] = tables.size == 0
      tables
    end

    def copy_database(from,to,conf_name = nil)
      logger.info "Copying database #{from} to #{to}"
      tables = db_tables(nil,conf_name)
      conf = config(conf_name,:database => from, :admin => true)

      remote_sql("CREATE DATABASE #{to};", :config => conf)
      sql = ''
      tables.each do |table|
        sql += <<-END 
          CREATE TABLE #{to}.#{table} LIKE #{from}.#{table};
          INSERT INTO #{to}.#{table} SELECT * FROM #{from}.#{table};
        END
      end
      remote_sql(sql, :config => conf)
      @db_status.delete(to)
    end

    def rename_database(from,to,conf_name = nil)
      logger.info "Renaming database #{from} to #{to}"
      conf = config(conf_name,:database => from, :admin => true)
      sql = ''
      if conf[:driver] == :mysql
        sql += "CREATE DATABASE `#{to}`;"
        db_tables(from,conf_name).each do |table|
          sql += "RENAME TABLE `#{from}`.`#{table}` TO `#{to}`.`#{table}`;"
        end
        sql += "DROP DATABASE `#{from}`;"
      else
        sql += "ALTER TABLE #{from} RENAME TO #{to};"
      end
      remote_sql(sql, :config => conf)
      @db_status.delete(to)
    end

    def drop_database(db,conf_name = nil)
      logger.info "Dropping database #{db}"
      conf = config(conf_name,:database => db, :admin => true)
      remote_sql("DROP DATABASE #{db};", :config => conf)
      @db_status[db] = false
    end

    # Should split these out
    def self.deep_update(h1,h2)
      h1.inject({}) do |h,(k,v)|
        if Hash === v && Hash === h2[k]
          h[k] = deep_update(v,h2[k])
        else
          h[k] = h2.key?(k) ? h2[k] : v
        end
        h
      end
    end

    def self.deep_merge(h1,h2)
      merger = proc { |key,v1,v2| Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2 }
      h1.merge(h2, &merger)
    end

    def self.each_db(databases)
      databases.each do |site_name,site|
        site.each do |db_name,db|
          yield db,site_name,db_name
        end
      end
    end

    def self.url(db)
      missing_keys = %w(driver username password host port database).delete_if {|k| db.key? k.to_sym}
      throw FieldNotFound.new missing_keys unless missing_keys.empty?
      
      "#{db[:driver]}://#{db[:username]}:#{db[:password]}@#{db[:host]}:#{db[:port]}/#{db[:database]}"
    end
  end
end
